from fastapi import APIRouter, File, UploadFile, HTTPException, Header, Form
from app.auth import verify_id_token, db, bucket  # Assuming 'bucket' is firebase_admin.storage.bucket()
from firebase_admin import firestore
import uuid
from typing import List, Optional

# Correct imports for Google Cloud Vision
from google.cloud import vision_v1  # Often aliased as 'vision'
from pydantic import BaseModel

# For environment variables and AI configuration
from dotenv import load_dotenv
import google.generativeai as genai
import os
from google.cloud import storage  # Import storage for delete scenario

# --- Configuration ---
load_dotenv()  # Load environment variables from .env file

# Ensure your GCS_BUCKET_NAME is correct and matches your Cloud Storage bucket
# THIS IS THE CORRECTED BUCKET NAME
GCS_BUCKET_NAME = "whatif-backend-462323.firebasestorage.app"


# Configure Gemini AI
genai.configure(api_key=os.getenv("GOOGLE_GENAI_API_KEY"))
vertex_model = genai.GenerativeModel(model_name="models/gemini-1.5-flash")


# --- Helper Function for AI Story Generation ---
async def generate_scenario_story(prompt: str) -> str:
    """
    Generates an immersive 'What If' scenario story using Gemini AI.
    """
    full_prompt = f"Based on this memory: '{prompt}', generate an immersive 'What If' scenario story:"
    try:
        response = await vertex_model.generate_content(full_prompt)
        return response.text if response.text else "[No content generated by AI]"
    except Exception as e:
        print(f"Generative AI story generation failed: {e}")
        return "[AI story generation failed due to an error]"


router = APIRouter()

# Initialize Vision AI client (ensure GOOGLE_APPLICATION_CREDENTIALS is set)
vision_client = vision_v1.ImageAnnotatorClient()
storage_client = storage.Client()  # Initialize storage client for delete_scenario


# Helper: Upload image to Firebase Storage
def upload_to_storage(file: UploadFile, user_id: str) -> str:
    try:
        blob_path = f"users/{user_id}/photos/{uuid.uuid4()}-{file.filename}"
        blob = bucket.blob(blob_path)
        blob.upload_from_file(file.file, content_type=file.content_type)
        blob.make_public()
        return blob.public_url
    except Exception as e:
        print(f"Storage upload error: {e}")
        raise HTTPException(status_code=500, detail="Failed to upload image to storage")


# Helper: Vision AI label detection
def get_image_labels(image_bytes: bytes) -> list:
    try:
        image = vision_v1.Image(content=image_bytes)
        response = vision_client.label_detection(image=image)
        if response.error.message:
            raise HTTPException(status_code=500, detail=f"Vision API error: {response.error.message}")
        return [label.description for label in response.label_annotations]
    except HTTPException as e:
        raise e
    except Exception as e:
        print(f"Vision AI error: {e}")
        raise HTTPException(status_code=500, detail="Failed to analyze image with Vision AI")


# CREATE SCENARIO (with Photo Upload and AI Story)
@router.post("/")
async def create_scenario(
        photos: Optional[List[UploadFile]] = File(None),
        id_token: str = Header(...),
        title: str = Form(...),
        prompt: str = Form(...)
):
    try:
        user_id = verify_id_token(id_token)
        image_urls = []
        ai_labels = []
        original_filenames = []

        if photos:
            for photo in photos:
                content = await photo.read()
                labels = get_image_labels(content)
                ai_labels.extend(labels)

                photo.file.seek(0)
                url = upload_to_storage(photo, user_id)
                image_urls.append(url)
                original_filenames.append(photo.filename)

        ai_generated_story = await generate_scenario_story(prompt)

        scenario_id = str(uuid.uuid4())
        scenario_data = {
            "user_id": user_id,
            "title": title,
            "prompt": prompt,
            "story": ai_generated_story,
            "imageUrls": image_urls,
            "original_filenames": original_filenames,
            "ai_labels": list(set(ai_labels)),
            "createdAt": firestore.SERVER_TIMESTAMP,
        }
        await db.collection("scenarios").document(scenario_id).set(scenario_data)

        response_data = scenario_data.copy()
        response_data["id"] = scenario_id
        response_data.pop("createdAt", None)

        return response_data

    except ValueError as e:
        raise HTTPException(status_code=401, detail=f"Authentication error: {e}")
    except HTTPException as e:
        raise e
    except Exception as e:
        print(f"Create scenario error: {e}")
        raise HTTPException(status_code=500, detail=f"Could not process request: {e}")


# READ SCENARIOS
@router.get("/")
async def get_scenarios(id_token: str = Header(...)):
    try:
        user_id = verify_id_token(id_token)
        docs_stream = (
            db.collection("scenarios")
            .where("user_id", "==", user_id)
            .order_by("createdAt", direction=firestore.Query.DESCENDING)
            .stream()
        )

        scenarios = []
        for doc in docs_stream:
            scenarios.append({**doc.to_dict(), "id": doc.id})

        return scenarios

    except ValueError as e:
        raise HTTPException(status_code=401, detail=f"Authentication error: {e}")
    except Exception as e:
        print(f"Fetch scenarios error: {e}")
        raise HTTPException(status_code=500, detail=f"Could not fetch scenarios: {e}")


# UPDATE SCENARIO
class ScenarioUpdate(BaseModel):
    title: Optional[str] = None
    prompt: Optional[str] = None


@router.put("/{scenario_id}")
async def update_scenario(scenario_id: str, update_data: ScenarioUpdate, id_token: str = Header(...)):
    try:
        user_id = verify_id_token(id_token)
        doc_ref = db.collection("scenarios").document(scenario_id)
        doc = await doc_ref.get()

        if not doc.exists:
            raise HTTPException(status_code=404, detail="Scenario not found")

        if doc.to_dict().get("user_id") != user_id:
            raise HTTPException(status_code=403, detail="Not authorized")

        update_fields = {}
        if update_data.title is not None:
            update_fields["title"] = update_data.title
        if update_data.prompt is not None:
            update_fields["prompt"] = update_data.prompt

        if not update_fields:
            raise HTTPException(status_code=400, detail="No valid fields provided for update.")

        await doc_ref.update(update_fields)

        return {"message": f"Scenario {scenario_id} updated successfully"}

    except ValueError as e:
        raise HTTPException(status_code=401, detail=f"Authentication error: {e}")
    except HTTPException as e:
        raise e
    except Exception as e:
        print(f"Update scenario error: {e}")
        raise HTTPException(status_code=500, detail=f"Could not update scenario: {e}")


# DELETE SCENARIO
@router.delete("/{scenario_id}")
async def delete_scenario(scenario_id: str, id_token: str = Header(...)):
    try:
        user_id = verify_id_token(id_token)
        doc_ref = db.collection("scenarios").document(scenario_id)
        doc = await doc_ref.get()

        if not doc.exists:
            raise HTTPException(status_code=404, detail="Scenario not found")

        if doc.to_dict().get("user_id") != user_id:
            raise HTTPException(status_code=403, detail="Not authorized")

        # Optional: Delete associated image from GCS if imageUrls exist
        scenario_data = doc.to_dict()
        if "imageUrls" in scenario_data and scenario_data["imageUrls"]:
            for url in scenario_data["imageUrls"]:
                try:
                    # Blob name is everything after the bucket name in the URL path
                    path_parts = url.split(f"/{GCS_BUCKET_NAME}/")
                    if len(path_parts) > 1:
                        blob_name = path_parts[1].split('?')[0]  # Remove query parameters
                        # Initialize storage_client here if not global, or ensure it's passed
                        bucket_obj = storage_client.bucket(GCS_BUCKET_NAME)
                        blob_obj = bucket_obj.blob(blob_name)
                        if blob_obj.exists():
                            blob_obj.delete()
                            print(f"Deleted GCS object: {blob_name}")
                        else:
                            print(f"GCS object not found for deletion: {blob_name}")
                except Exception as gcs_e:
                    print(f"Error deleting GCS object {url}: {gcs_e}")

        await doc_ref.delete()
        return {"message": f"Scenario {scenario_id} deleted successfully"}

    except ValueError as e:
        raise HTTPException(status_code=401, detail=f"Authentication error: {e}")
    except HTTPException as e:
        raise e
    except Exception as e:
        print(f"Delete scenario error: {e}")
        raise HTTPException(status_code=500, detail=f"Could not delete scenario: {e}")